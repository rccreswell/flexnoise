"""Multivariate Gaussian likelihood for time series in Pints.
"""

import math
import numpy as np
import pints
import scipy.stats
from sksparse.cholmod import cholesky
from sksparse.cholmod import CholmodNotPositiveDefiniteError
import sys


class CovarianceLogLikelihood(pints.ProblemLogLikelihood):
    """Multivariate Gaussian likelihood.

    This likelihood treats the entire time series as one draw from a
    multivariate normal distribution. The mean of the multivariate normal is
    given by the problem model, while the covariance matrix is supplied when
    the likelihood is instantiated.

    Extends :class:`pints.ProblemLogLikelihood`.
    """
    def __init__(self, problem, cov, exceptions='inf'):
        """
        Parameters
        ----------
        problem : pints.Problem
            The Pints problem for this time series.
        cov : numpy.ndarray or scipy.sparse.csc_matrix
            The covariance matrix for the multivariate normal likelihood.
            Either a 2d Numpy array or a 2d sparse matrix in Scipy sparse CSC
            format can be provided. For long time series, the sparse matrix
            will have significant performance advantages.
        exceptions : {'strict', 'inf'}, optional ('inf')
            How to treat exceptions during the calculation of the multivariate
            likelihood. If 'inf', exceptions are ignored and -inf is returned
            as the likelihood. If 'strict', the exceptions are raised and the
            program is stopped.
        """
        super(CovarianceLogLikelihood, self).__init__(problem)
        self.cov = cov
        self._n_parameters = problem.n_parameters()
        self.times = problem.times()
        self.exceptions = exceptions
        self.half_log_2pi = 0.9189385332046727

        if isinstance(self.cov, scipy.sparse.csc_matrix):
            self.use_sparse = True
        else:
            self.use_sparse = False

    def _ll_sparse(self, mean, cov):
        """Get the likelihood with a sparse covariance matrix
        """
        factor = cholesky(cov)
        ld = factor.logdet()
        data = self._values
        k = len(mean)
        ll = -k * self.half_log_2pi - 0.5 * ld - \
            0.5 * (data - mean).T @ factor.solve_A(data-mean)
        return ll

    def _ll_dense(self, mean, cov):
        """Get the likelihood with a dense covariance matrix
        """
        ll = scipy.stats.multivariate_normal.logpdf(
                self._values, mean=mean, cov=cov)
        return ll

    def _get_ll(self, model_params, cov):
        """Get the likelihood with model parameters and covariance matrix
        """
        try:
            mean = self._problem.evaluate(model_params)

            if self.use_sparse:
                return self._ll_sparse(mean, cov)

            else:
                return self._ll_dense(mean, cov)

        except (RuntimeError,
                ValueError,
                np.linalg.LinAlgError,
                CholmodNotPositiveDefiniteError):
            if self.exceptions == 'inf':
                return -math.inf
            elif self.exceptions == 'strict':
                print('likelihood failed ', sys.exc_info()[0])
                raise

    def __call__(self, x):
        return self._get_ll(x, self.cov)


class KernelCovarianceLogLikelihood(CovarianceLogLikelihood):
    """Multivariate Gaussian likelihood with covariance generated by a kernel.

    This likelihood treats the entire time series as one draw from a
    multivariate normal distribution. The mean of the multivariate normal is
    given by the problem model, while the covariance matrix is generated from
    the time points by a parametrized kernel. The kernel parameters must be
    supplied as arguments to the likelihood calls after the model parameters.

    Extends :class:`CovarianceLogLikelihood`.
    """
    def __init__(self, problem, kernel, exceptions='inf', use_sparse=True):
        """
        Parameters
        ----------
        problem : pints.Problem
            The Pints problem for this time series.
        kernel : CovKernel
            A kernel object with get_matrix or get_sparse_matrix method.
        exceptions : {'strict', 'inf'}, optional ('inf')
            How to treat exceptions during the calculation of the multivariate
            likelihood. If 'inf', exceptions are ignored and -inf is returned
            as the likelihood. If 'strict', the exceptions are raised and the
            program is stopped.
        use_sparse : bool, optional (True)
            Whether or not to use the sparse covariance matrix.
        """
        super(KernelCovarianceLogLikelihood, self).__init__(problem, None)
        self.kernel = kernel
        self.num_kernel_parameters = kernel.num_parameters()
        self._n_parameters = problem.n_parameters() + kernel.num_parameters()
        self.times = problem.times()
        self.sparse_threshold = 1e-9
        self.use_sparse = use_sparse
        self.exceptions = exceptions
        self.half_log_2pi = 0.9189385332046727

    def __call__(self, x):
        model_parameters = x[:-self.num_kernel_parameters]
        kernel_parameters = x[-self.num_kernel_parameters:]

        # Update the kernel object with the parameters that have been supplied
        # to this likelihood
        self.kernel.parameters = kernel_parameters

        # Get the covariance matrix
        if self.use_sparse:
            cov = self.kernel.get_sparse_matrix(
                            self.times, self.sparse_threshold)
        else:
            cov = self.kernel.get_matrix(self.times)

        return self._get_ll(model_parameters, cov)


class KnownBlocksCovarianceLogLikelihood(CovarianceLogLikelihood):
    """Multivariate Gaussian likelihood.

    The block structure is known and prespecified. However, the kernel
    parameter values within each block are unknown. Therefore, the likelihood
    incorporates some uncertainty in the noise process.

    Parameters
    ----------
    kernel CovKernel
        The kernel to use within each block
    blocks
        list of lists giving the indices of the time points in each block
        eg, [[0,1,2,3], [4,5,6,7], [8,9,10]], for three blocks
    """
    def __init__(self, problem, kernel, blocks, use_sparse=True):
        super(KnownBlocksCovarianceLogLikelihood, self).__init__(problem, None)
        self.kernel = kernel
        self.blocks = blocks
        self.num_kernel_parameters = kernel.num_parameters() * len(blocks)
        self._n_parameters = problem.n_parameters() \
            + self.num_kernel_parameters
        self.times = problem.times()
        self.sparse_threshold = 1e-9

        # Make an array giving the times in each block
        self.block_times = []
        for block in self.blocks:
            self.block_times.append(self.times[block])

        self.use_sparse = use_sparse

    def __call__(self, x):
        # x = [model_params, kernel params block1, kernel params block2, ...]
        model_parameters = x[:-self.num_kernel_parameters]
        kernel_parameters = x[-self.num_kernel_parameters:]

        cov_blocks = []
        for block_times, block_params in zip(
                self.block_times,
                np.array_split(kernel_parameters, len(self.blocks))):
            self.kernel.parameters = block_params.copy()
            if self.use_sparse:
                cov = self.kernel.get_sparse_matrix(
                                block_times, self.sparse_threshold).copy()
            else:
                cov = self.kernel.get_matrix(block_times).copy()
            cov_blocks.append(cov)

        if self.use_sparse:
            cov_matrix = scipy.sparse.block_diag(cov_blocks, format='csc')

        else:
            cov_matrix = scipy.linalg.block_diag(*cov_blocks)

        return self._get_ll(model_parameters, cov_matrix)
